#!/bin/sh
set -e

# Applies a highly restrictive network setup in which only squid (80,443), dnsmasq (53) and chrony (123)
# are allowed outgoing external network access.
# This is facilitated via the iptables --uid-owner $USER [dnsmasq|_chrony|proxy]

PROJDIR="$( realpath $0 | xargs dirname )"
DEFAULT_ROUTE=$(ip route | grep '^default' | head -1)
ROUTE_ADDR=$(echo "$DEFAULT_ROUTE" | awk '{print $3}')
INTERFACE=$(echo "$DEFAULT_ROUTE" | awk '{print $5}')

# For ufw/iptables config
ALLOW_CHAIN="ALLOW-OUT-${INTERFACE}"
DENY_CHAIN="DENY-OUT-${INTERFACE}"
RULES_FILE="/etc/ufw/before.rules.d/60-transparent-proxy-lockdown.rules"

# For squid blacklist management
CACHE_LOG_FILEPATH=".access_log_filepath"
CONFDIR="/etc/squid"
BLACKLIST="$CONFDIR/blacklist_domains.txt"
ACCESS_LOG=""
DNS_LOG="/var/log/dnsmasq.log"

PROXY_USER=proxy
DNS_USER=dnsmasq
NTP_USER=_chrony

#
# Commands used throughout script
#

_require_root()
{
    if [ "$USER" != "root" ]; then
        echo "ERROR: root permissions are required"
        exit 1
    fi
}

_install_deps()
{
    _require_root
    local run_install=0
    which ufw > /dev/null 2>&1 || run_install=1
    which squid > /dev/null 2>&1 || run_install=1
    which dnsmasq > /dev/null 2>&1 || run_install=1
    which chronyc > /dev/null 2>&1 || run_install=1
    
    if [ "$run_install" = "1" ]; then
        apt install squid dnsmasq chrony ufw > /dev/null 2>&1
    fi

    # verify the expected users exist
    ( grep -q $PROXY_USER /etc/shadow \
        && grep -q $DNS_USER /etc/shadow \
        && grep -q $NTP_USER /etc/shadow ) \
        || ( echo "ERROR: Unable to determine users for service." && exit 1 )

    local squid_conf="/etc/squid/squid.conf"
    if [ -f "$squid_conf" ]; then
        _print_squid_conf > /tmp/.calamari_squid.conf

        if ! cmp --silent $squid_conf /tmp/.calamari_squid.conf; then
            echo "Current Squid config file doesn't match calamari settings."
            read -p "Replace it? (y/n): " F_INPUT

            if [ "${F_INPUT}" = "y" ] || [ "${F_INPUT}" = "Y" ]; then
                cp $squid_conf $squid_conf".orig"
                mv /tmp/.calamari_squid.conf $squid_conf
                if [ ! -f "${BLACKLIST}" ]; then
                    cp "${PROJDIR}/config/blacklist_domains.txt" "$BLACKLIST"
                fi

                _setup_squid_auth
                echo -n "Restarting squid..."
                service squid restart
                echo " done."
            fi
        fi
    fi
    
    local dns_conf="/etc/dnsmasq.conf"
    local restart_dnsmasq=0
    if [ ! -f "$dns_conf" ]; then
        echo "ERROR: Missing dnsmasq.conf file."
        exit 1
    fi
    if ! grep -q ^server= "$dns_conf"; then
        sed -i 's/# server=10.1.2.3@eth1/# server=10.1.2.3@eth1\nserver=8.8.8.8/' "$dns_conf"
        restart_dnsmasq=1
    fi
    if [ -f "$BLACKLIST" ] ; then
        reload=0
        for domain in $( cat $BLACKLIST | sed 's/^\.//g' ) ; do
            if ! grep -q ^address=/$domain/127.0.0.1 $dns_conf ; then
                find_pattern="#address=/www.thekelleys.org.uk/fe80::20d:60ff:fe36:f83"
                replace_with="$find_pattern\naddress=/$domain/127.0.0.1"
                sed -i 's_'$find_pattern'_'$replace_with'_' $dns_conf
                reload=1
            fi
        done
        test $reload -gt 0 && service dnsmasq reload
    fi
    if ! grep -q ^log-queries "$dns_conf"; then
        cp "$dns_conf" "${dns_conf}.backup.$(date +%Y%m%d)"
        # Append logging directives
        echo "log-queries" >> "$dns_conf"
        echo "log-facility=$DNS_LOG" >> "$dns_conf"
        restart_dnsmasq=1
    fi
    if ! grep -q ^interface= "$dns_conf"; then
        sed -i 's/#interface=/interface=lo/' "$dns_conf"
        sed -i 's/#bind-interfaces/bind-interfaces/' "$dns_conf"
        restart_dnsmasq=1
    fi
    if [ "$restart_dnsmasq" = "1" ]; then
        service dnsmasq restart
    fi
}

_start_required_services()
{
    _require_root
    service chrony start
    service dnsmasq start
    service squid start
    chattr -i /etc/resolv.conf > /dev/null 2>&1
    echo "nameserver 127.0.0.1" > /etc/resolv.conf
    chattr +i /etc/resolv.conf > /dev/null 2>&1
}

_prompt_allow_ssh_user()
{
    _require_root
    echo "Would you like to enable outgoing SSH access for any users?"
    echo "    0) Add a new user"
    ulist=""
    for u in $( users | sed 's/\ /\n/g' | sort | uniq )
    do
        echo "    1) $u"
        ulist="$ulist $u"
    done
    read -p "Selection: " F_INPUT
    if [ "$F_INPUT" = "0" ]; then
        echo 'no.'
        return 1
    elif [ -n "$F_INPUT" ]; then
        allow_user="$( echo "$ulist" | awk '{ print $'$F_INPUT' }' )"
        echo "Allowing SSH for user: ${allow_user}"
        iptables -A $ALLOW_CHAIN -o "$INTERFACE" -p tcp --dport 22 -m owner --uid-owner "${allow_user}" -j ACCEPT
        return 0
    fi
}

_disable_ipv6()
{
    sysctl -w net.ipv6.conf.all.disable_ipv6=1
    sysctl -w net.ipv6.conf.default.disable_ipv6=1
}

_enable_ipv6()
{
    sysctl -w net.ipv6.conf.all.disable_ipv6=0
    sysctl -w net.ipv6.conf.default.disable_ipv6=0
}

_setup_squid_auth()
{
    _require_root
    local auth_type="basic"
    local passwd_file="/etc/squid/passwords"
    local squid_conf="/etc/squid/squid.conf"

    read -p "Would you like to add basic password protection to proxy access? (y/n): " F_INPUT
    if [ "${F_INPUT}" != "y" ] && [ "${F_INPUT}" != "Y" ]; then
        return 0
    fi

    which htpasswd >/dev/null 2>&1 || apt install apache2-utils -y

    echo "Creating/managing password file at $passwd_file"

    if [ ! -f "$passwd_file" ]; then
        touch "$passwd_file"
        chown proxy:proxy "$passwd_file"
        chmod 600 "$passwd_file"
    fi

    echo "Adding/updating user for Basic auth..."
    read -p "Username: " username
    htpasswd "$passwd_file" "$username"
    
    # Remove auth lines
    sed -i 's/^#auth_param/auth_param/' "$squid_conf"
    sed -i 's/^#acl authenticated/acl authenticated/' "$squid_conf"
    sed -i 's/^http_access allow localhost manager/http_access allow authenticated/' "$squid_conf"
}

_list_squid_users()
{
    local passwd_file="/etc/squid/passwords"

    if [ ! -f "$passwd_file" ]; then
        echo "No password file found. Authentication is not enabled."
        return 0
    fi

    echo "=== Squid Proxy Users ==="
    # Basic format: user:hash
    echo "Basic authentication users:"
    cut -d: -f1 "$passwd_file" | sort | uniq
    echo ""
}

_print_squid_conf()
{
echo "
acl SSL_ports port 443
acl Safe_ports port 80      # http
acl Safe_ports port 443     # https

#auth_param basic program /usr/lib/squid/basic_ncsa_auth /etc/squid/passwords
#auth_param basic realm proxy
#acl authenticated proxy_auth REQUIRED

acl domain_blacklist dstdomain "$BLACKLIST"

http_access deny all domain_blacklist
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
http_access allow localhost manager
http_access deny manager
http_access allow localhost
http_access deny to_localhost
http_access deny to_linklocal

http_access deny all

http_port 127.0.0.1:3128
dns_nameservers 127.0.0.1

coredump_dir /var/spool/squid
refresh_pattern .       0   20% 4320
"
}


#
# Functions for reporting on squid domains being blocked or access, as well as allowing
# quick access to blocking or unblocking domains from a squid blacklist.
#

_require_access_log()
{
    # Check for existing input for the squid access_log filepath
    if [ -f ".access_log_filepath" ] ; then
        ACCESS_LOG="$(cat "${PROJDIR}/${CACHE_LOG_FILEPATH}")"
    fi

    # Try guessing
    local log_filepath="$( ps -u $PROXY_USER -o args= | grep 'access.log' | cut -d ' ' -f 2 )"
    if [ -f "${log_filepath}" ]; then
        ACCESS_LOG="${log_filepath}"
    fi
    
    # Required input of access_log location, can be previously set by config file, etc
    if [ -z "${ACCESS_LOG}" ] || [ ! -f "${ACCESS_LOG}" ]; then
        read -p "Squid Log file location: " F_INPUT
        if [ -f "${F_INPUT}" ]; then
            echo "Using ${F_INPUT}"
            echo "${F_INPUT}" > "${PROJDIR}/$CACHE_LOG_FILEPATH"
            ACCESS_LOG="${F_INPUT}"
        else
            echo "File not found."
            exit 1
        fi
    fi
}

_prompt_squid_restart()
{
    # $1 = message proceeding prompt
    if [ "$1" != "" ]; then
        echo "$1"
    fi

    read -p "Continue with service restart? (y/n): " F_INPUT
    if [ "${F_INPUT}" = "y" ] || [ "${F_INPUT}" = "Y" ]; then
        service squid restart
    fi
}


allow_domain()
{
    if [ "${1}" = "" ] || [ "${1}" = "-h" ]; then
        echo "  allow [DOMAIN]"
        echo "      Where DOMAIN matches an entry in the squid blacklist."
        echo "      Example: .google.com"
        exit 0
    fi

    # Check that the $1 is in the file
    if [ -f "${BLACKLIST}" ]; then
        grep -q "${1}" "${BLACKLIST}" || (echo "Domain $1 is not blacklisted." && exit 1)
    fi

    sed -i -e 's/'$1'//g' "${BLACKLIST}" \
        && _prompt_squid_restart "Squid must restart for changes to be applied."
}


deny_domain()
{
    if [ "${1}" = "" ] || [ "${1}" = "-h" ]; then
        echo "  deny [DOMAIN]"
        echo "      Where DOMAIN can include sub-domains by prepending it with a period."
        echo "      Example: .google.com vs. google.com - where the form blacklists all sub-domains as well."
        exit 0
    fi

    # Check that the $1 isn't already in the file
    if [ -f "${BLACKLIST}" ]; then
        grep -q "${1}" "${BLACKLIST}" && echo "Domain $1 is already blacklisted." && exit 1
    fi

    echo "${1}" >> "${BLACKLIST}"
    if [ "$?" != "0" ]; then
        echo "WARNING: failed to blacklist $1"
        exit 1
    elif [ -z "${2}" ] || [ "${2}" != "-n" ]; then 
        _prompt_squid_restart "Squid must restart for changes to be appplied."
    fi
}


print_top_domains()
{
    if [ "${1}" = "-h" ]; then
        echo "  squid-top-domains [LIMIT]"
        echo "      List top domains access in squid logs."
        exit 0
    fi

    # Strip extension from filepath to allow wildcard to include .log.1, .log.2, etc
    local access_logs="$(dirname $ACCESS_LOG)/$(basename $ACCESS_LOG .log)"
    local limit=2000

    if [ ! -z "$1" ]; then
        limit=$1
    fi
    
    # numbered; idea being for selection to add to blacklist
    grep 'TCP_TUNNEL' "${access_logs}".* \
        | awk '{ print $7 }' \
        | sort | uniq -c | sort -n \
        | awk '{ lc++ }  { print lc "    ("$1") "$2 }'
}


print_denied_domains()
{
    if [ "${1}" = "-h" ]; then
        echo "  squid-denied-domains [LIMIT]"
        echo "      List top denied domains rejected access in squid logs."
        exit 0
    fi

    # Strip extension from filepath to allow wildcard to include .log.1, .log.2, etc
    local access_logs="$(dirname $ACCESS_LOG)/$(basename $ACCESS_LOG .log)"
    local limit=2000
 
    if [ ! -z "$1" ]; then
        limit=$1
    fi

    # numbered; idea being for selection to add to blacklist
    grep 'TCP_DENIED' "${access_logs}".* \
        | awk '{ print $7 }' \
        | sort | uniq -c | sort -n \
        | awk '{ lc++ }  { print lc "    ("$1") "$2 }'
}


#
# Util interface commmands 
#

list_services()
{
    echo "List of services to enable outgoing access to:"
    echo "    0) ssh"
    read -p "Selection: " F_INPUT
    if [ "$F_INPUT" = "0" ]; then
        _prompt_allow_ssh_user
    fi
}

show_dns_stats()
{
    _require_root
    local target_domain="${1}"
    local log_file="$DNS_LOG"

    if [ ! -f "$log_file" ]; then
        echo "DNS log file not found. Is dnsmasq logging enabled?"
        return 1
    fi

    echo "=== DNS Query Statistics ==="
    if [ -n "$target_domain" ]; then
        echo "Focusing on domain: $target_domain"
        grep "query\[A\] $target_domain" "$log_file" | \
            awk '{print $8}' | sort | uniq -c | sort -rn | head -20
    else
        # Show top domains overall
        awk '/query\[A\]/ {print $8}' "$log_file" | \
            cut -d. -f2- | sort | uniq -c | sort -rn | head -20
    fi
}

audit_dns_queries()
{
    _require_root
    local log_file="$DNS_LOG"
    local alert_threshold=100  # Adjust as needed

    if [ ! -f "$log_file" ]; then
        echo "DNS log file not found."
        return 1
    fi

    echo "=== DNS Exfiltration Anomaly Check ==="

    # Check for very long subdomains (potential data encoding)
    echo "Checking for unusually long subdomains..."
    awk '/query\[A\]/ && length($8) > 80 {print "LONG:", $8}' "$log_file" | head -10

    # Check for high entropy/Base64-like patterns
    echo "Checking for high-entropy subdomains..."
    grep -oE 'query\[A\] [^ ]+' "$log_file" | \
        awk '{print $2}' | grep -E '[a-zA-Z0-9+/=]{20,}' | \
        head -10 | sed 's/^/ENTROPY: /'

    # Alert on sudden volume spikes (last 10 minutes)
    echo "Checking recent query volume..."
    recent_count=$(find "$log_file" -mmin -10 -exec grep -c 'query\[A\]' {} \; 2>/dev/null)
    if [ -n "${recent_count}" ] && [ "$recent_count" -gt "$alert_threshold" ]; then
        echo "ALERT: High DNS query volume detected: $recent_count queries in last 10 minutes"
    fi

    # Show suspicious TLDs
    echo "Checking for unusual TLDs..."
    awk '/query\[A\]/ {print $8}' "$log_file" | \
        rev | cut -d. -f1 | rev | sort | uniq -c | \
        grep -E -v 'com|net|org|io|local' | sort -rn | head -5
}


#
# iptable modifications to restrict local access to external networks except
# through squid, dnsmasq
#

apply_live()
{
    _install_deps
    remove_live > /dev/null 2>&1
    _disable_ipv6
    yes | ufw reset > /dev/null 2>&1
    ufw enable > /dev/null 2>&1

    echo "Applying LIVE (non-persistent) locked-down mode..."
    
    iptables -F $ALLOW_CHAIN 2>/dev/null || iptables -N $ALLOW_CHAIN
    iptables -F $DENY_CHAIN  2>/dev/null || iptables -N $DENY_CHAIN

    # Remove old jumps if they exist
    iptables -D ufw-before-output -o "$INTERFACE" -j $ALLOW_CHAIN 2>/dev/null || true
    iptables -D ufw-before-output -o "$INTERFACE" -j $DENY_CHAIN  2>/dev/null || true

    # Jump from UFW's chain into ours
    iptables -A ufw-before-output -o "$INTERFACE" -j $ALLOW_CHAIN
    iptables -A ufw-before-output -o "$INTERFACE" -j $DENY_CHAIN

    # === Your actual allow rules (copy-paste exactly from your working set) ===
    if [ "$1" = "tor" ] ; then
        which tor > /dev/null 2>&1
        if [ "$?" != "0" ]; then
            echo ""
            echo "ERROR: Tor is not installed. Please install it first: apt install tor"
            echo ""
            echo "Note: If calamari is enabled in squid-mode, you may need to run './calamari off', or use:"
            echo "  \$ env http_proxy=http://127.0.0.1:3128 https_proxy=http://127.0.0.1:3128 apt update && apt install tor"
            echo ""
            echo "WARNING: If a password is required, su as root for some protection, as the password will likely end up in your shell history."
            echo ""
            remove_live
            exit 1
        fi

        # Start tor if not running
        if ! service tor status >/dev/null 2>&1; then
            service tor start > /dev/null 2>&1
            sleep 2  # Give tor time to start
        fi

        tor_user="$(ps -eo user:20,pid,cmd | awk '/\/bin\/[t]or/ {print $1}')"

        if [ -z "$tor_user" ]; then
            echo "ERROR: Could not find running tor process."
            echo "Check: service tor status"
            exit 1
        fi

        iptables -A $ALLOW_CHAIN -o "$INTERFACE" -m owner --uid-owner $tor_user -j ACCEPT
    else
        iptables -A $ALLOW_CHAIN -o "$INTERFACE" -p tcp -m multiport --dports 80,443 -m owner --uid-owner $PROXY_USER -j ACCEPT
        iptables -A $ALLOW_CHAIN -o "$INTERFACE" -p udp --dport 53 -m owner --uid-owner $DNS_USER -j ACCEPT
        iptables -A $ALLOW_CHAIN -o "$INTERFACE" -p tcp --dport 53 -m owner --uid-owner $DNS_USER -j ACCEPT
    fi
    iptables -A $ALLOW_CHAIN -o "$INTERFACE" -p udp --dport 123 -m owner --uid-owner $NTP_USER -j ACCEPT
    # @TODO - narrow down to specific ports+protocols?
    iptables -A $ALLOW_CHAIN -o "$INTERFACE" -p tcp -m owner --uid-owner root -d "$ROUTE_ADDR" -j ACCEPT
    iptables -A $ALLOW_CHAIN -o "$INTERFACE" -p udp -m owner --uid-owner root -d "$ROUTE_ADDR" -j ACCEPT
    # @TODO - add dnsmasq.conf including using default route for DNS is a query to it works?

    _prompt_allow_ssh_user

    # ICMP for Path MTU (uncomment if you want it)
    # iptables -A $ALLOW_CHAIN -o "$INTERFACE" -p icmp --icmp-type 8 -j ACCEPT

    # Final drop everything else
    iptables -A $DENY_CHAIN -j DROP

    _start_required_services
    if [ "$1" = "tor" ]; then
        echo "Locked-down mode using TOR is now ACTIVE (non-persistent – reboot to remove)"
    else
        echo "Locked-down mode is now ACTIVE (non-persistent – reboot to remove)"
    fi
}

remove_live()
{
    _require_root
    _enable_ipv6
    echo "Removing temporary locked-down rules..."
    iptables -D ufw-before-output -o "$INTERFACE" -j $ALLOW_CHAIN 2>/dev/null || true
    iptables -D ufw-before-output -o "$INTERFACE" -j $DENY_CHAIN  2>/dev/null || true
    iptables -F $ALLOW_CHAIN 2>/dev/null || true
    iptables -X $ALLOW_CHAIN 2>/dev/null || true
    iptables -F $DENY_CHAIN  2>/dev/null || true
    iptables -X $DENY_CHAIN  2>/dev/null || true
    echo "Back to normal UFW rules"
}


if [ -z "${INTERFACE}" ]; then
    echo "ERROR: Could not detect default network interface."
    exit 1
else
    echo "Detected primary interface: $INTERFACE"
fi


case "$1" in
    on|temp|live)
        apply_live $2
        ;;
    tor)
        apply_live "tor"
        ;;
    off)
        remove_live
        ;;
    commit|permanent)
        commit_rules
        ;;
    services)
        list_services
        ;;
    deny|squid-deny)
        _require_access_log
        deny_domain $2 $3
        ;;
    allow|squid-allow)
        _require_access_log
        allow_domain $2 $3
        ;;
    squid-top-domains|squidtopdomains)
        _require_access_log
        ret="$(print_top_domains $2 $3)"
        echo "${ret}" | less -RS
        read -p "Provide index number to block that domain: " F_INPUT
        if [ -n "$F_INPUT" ] ; then
            domain="$(echo "${ret}" | awk '/^'$F_INPUT' / { print $3 }' | cut -d: -f1 | tr -d ' ' )"
            if [ -n "${domain}" ] ; then 
                # @TODO - allow sub-domains to be removed
                echo -n "Blocking domain ${domain}.."
                deny_domain $domain -n
                echo ". done. This can be removed with $0 allow ${domain}."
                echo "WARNING - remember to restart squid with: \$ service squid restart"
            fi
        fi
        ;;
    squid-denied-domains|squid-denied-domains)
        _require_access_log
        print_denied_domains $2 $3
        ;;
    dns-audit)
        audit_dns_queries
        ;;
    dns-stats)
        show_dns_stats $2  # Pass a domain as optional argument
        ;;
    test-tor)
        if ! which torsocks >/dev/null 2>&1; then
            echo "torsocks not installed, exiting..."
            exit 1
        fi
        echo -n "Testing Tor connection... "
        timeout 30 torsocks curl -s https://check.torproject.org/ 2>&1| \
            grep -q -i "congratulations" && echo "✓ Tor is working!" || echo "✗ Tor connection failed"
        
        ;;
    status)
        echo "=== Firewall Status ==="
        if [ "$USER" != "root" ]; then
            echo "Information Not Available - requires root permission."
        else 
            iptables -L ALLOW-OUT-$INTERFACE -nv 2>/dev/null || echo "Rules not active."
        fi
        echo ""
        if service tor status > /dev/null 2>&1 ; then
            echo "=== TOR Status ==="
            echo "Tor user: $tor_user"
            service tor status | head -3
            echo ""
            echo "=== Configured Proxy Endpoints ==="
            echo "SOCKS5: 127.0.0.1:9050"
            echo "Control: 127.0.0.1:9051"
            echo "DNS: 127.0.0.1:9053 (if DNSPort enabled in /etc/tor/torrc)"
            echo ""
            echo "Test Tor connection:"
            echo "  torsocks curl -s https://check.torproject.org/ | grep -i congratulations"
            echo ""
        fi
        echo "=== Proxy Status ===" 
        service squid status | head -3
        echo ""
        _list_squid_users
        echo "=== Configured Proxy Endpoint ==="
        echo "HTTP Proxy: 127.0.0.1:3128"
        ;;
    *)
        echo "Usage: $0 {on|temp|live|off|tor|status|services|...}"
        echo "  on/temp/live [tor]  apply locked-down mode (add 'tor' for tor mode)"
        echo "  tor                 shortcut for 'on tor'"
        echo "  off                 remove temporary rules"
        echo "  status              show the current configuration status"
        echo "  services            list services to enable outgoing access to"
        echo "  dns-audit           basic check for obvious DNS Exfiltration attempts"
        echo "  dns-stats           show DNS stats"
        echo ""
        echo "Proxy management:"
        echo "$(deny_domain -h)"
        echo "$(allow_domain -h)"
        echo "$(print_top_domains -h)"
        echo "$(print_denied_domains -h)"
        exit 1
        ;;
esac
